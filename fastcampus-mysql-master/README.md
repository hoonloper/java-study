# 대용량 처리를 위한 MySQL 이해
## 1. 대용량 시스템에 대한 이해

### 대용량 트래픽 / 데이터 처리는 왜 어려울까?

- **하나의 서버로 감당하기 힘들어 대부분 여러개의 서버 또는 데이터베이스를 사용**함
- 여러개의 서버에서 유입되는 **데이터의 일관성을 보장**할 수 있어야함
- **코드 한줄이 데이터에 미치는 영향 범위가 굉장히 커짐**
- 여러 서비스들이 얽혀있어, **시스템 복잡도가 상당히 높음**

- **고가용성**
  → 언제든 서비스를 이용할 수 있어야 한다.
- **확장성**
  → 시스템이 비대해짐에 따라 증가하는 데이터와 트래픽에 대응할 수 있어야 한다.
- **관측가능성**
  → 문제가 생겼을 때 빠르게 인지할 수 있어야 하고 문제의 범위를 최소화 할 수 있어야 한다.

### **스케일 업 vs 스케일 아웃**

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2d154db6-5a60-4ae3-8ad9-b2538cf3ec62/Untitled.png)

### **모놀리식 서버의 부하**

1. 서버를 늘리고(스케일 아웃), 로드 밸런서를 부착
2. 데이터 베이스 캐시
3. 대외기관(외부 API) 비동기 큐

### **분산 아키텍처의 예**

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e037f3d2-b4b2-4f3f-ab48-fd43ffebc40f/Untitled.png)

## 2. MySQL

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/011a78b0-c4a4-437b-9b4b-3c3aeb05bbed/Untitled.png)

- **쿼리파서**
  → SQL을 파싱하여 Syntax Tree를 만듦, 이 과정에서 문법 오류 검사가 이루어짐
- **전처리기**
  → 쿼리파서에서 만든 Tree를 바탕으로 전처리 시작
  → 테이블이나 컬럼 존재 여부, 접근권한 등 Semantic 오류 검사

컴파일 과정과 매우 유사하다.
하지만 SQL은 프로그래밍 언어처럼 컴파일 타임때 검증할 수 없어 매번 구문 평가를 진행한다.

### 옵티마이저

- 쿼리를 처리하기 위한 여러 방법들을 만들고, 각 방법들의 비용정보와 테이블의 통계정보를 이용해 비용을 산정
- 테이블 순서, 불필요한 조건 제거, 통계정보를 바탕으로 전략을 결정 (실행 계획 수립)
- 옵티마이저가 어떤 전략을 결정하느냐에 따라 성능이 많이 달라짐
- 가끔씩 성능이 나쁜 판단을 해 개발자가 힌트를 사용해 도움을 줄 수 있음

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c40b574f-63ff-4ae5-a7af-ed732f01dc36/Untitled.png)

- **소프트 파싱**
  → SQL, 실행계획을 캐시에서 찾아 옵티마이저 과정을 생략하고 실행 단계로 넘어감
- **하드 파싱**
  → SQL, 실행계획을 캐시에서 찾지 못해 옵티마이저 과정을 거치고나서 실행단계로 넘어감

**MySQL에는 소프트 파싱이 없지만 5 버전까지는 쿼리 캐시가 있었다.**
쿼리캐시는 SQL에 해당하는 데이터를 저장하는 것이다.
쿼리캐시는 데이터를 캐시하기 때문에 테이블의 데이터가 변경되면 캐시의 데이터도 함께 갱신시켜줘야 한다.

**Oracle에는 소프트 파싱이 존재**한다.
실행계획까지만 캐싱한다.
하지만 모든 SQL과 맵핑해 데이터까지 캐싱하지는 않는다.(힌트나 설정으로 가능하긴 하다)

- MySQL의 쿼리캐시, Oracle의 소프트 파싱 **모두 성능 최적화를 위해 캐시라는 기술을 도입**한 사례이다.
- 그러나 캐시의 범위가 다르다.
- 캐시를 도입할 때는 항상 만료정책을 고려해야 한다.
- 쿼리 캐시는 소프트 파싱에 비해 조회 성능은 더 높지만, 캐시 데이터 관리에 더 높은 비용이 들어간다.

⭐️ **모든 기술은 트레이드 오프다.**

**스토리지 엔진**

- **디스크에서 데이터를 가져오거나 저장하는 역할**을 수행한다.
- MySQL 스토리지 엔진은 플러그인 형태로 Handler API만 맞춘다면 직접 구현해서 사용할 수 있다.
- InnoDB, Mylsam 등 여러개의 스토리지 엔진이 존재한다.
- 8.0대 부터는 **InnoDB 엔진**을 디폴트이다.

**InnoDB 핵심 키워드 → Clustered Index, Redo - Undo, Buffer pool**

## 3. 정규화 - 비정규화

> **테이블 설계 관점에서 조회와 쓰기 사이의 트레이드 오프**
>

**정규화**

- 중복을 최소화하게 데이터를 구조화하는 프로세스
  → 중복을 제거하고 한 곳에서만 데이터를 관리
- 읽을 때는 항상 원본 데이터를 참조하는 단점
- 데이터 정합성 유지가 쉬움
- 읽기시 참조 발생

**반(비)정규화**

- 읽기의 성능을 갖기 위해, 쓰기의 성능을 어느정도 포기
- 중복을 허용
- 데이터 정합성 유지가 어려움
- 참조없이 읽기 가능

### 중복된 데이터이면 반드시 정규화를 해야 하는 걸까?

- 사실 실무에서 중복 데이터면 기계적으로 정규화하는 분들이 종종 있다.
- **정규화도 비용이다**. 읽기 비용을 지불하고 쓰기 비용을 줄이는 것

**정규화시 고려해야 하는 것**

- 얼마나 빠르게 데이터의 최신성을 보장해야 하는가?
- 히스토리성 데이터는 오히려 정규화를 하지 않아야 한다
- 데이터 변경 주기와 조회 주기는 어떻게 되는가?
  변경 주기가 잦으면 쓰기 이점을 가져가고, 반대면 조회의 이점을 가져간다.
- 객체(테이블) 탐색 깊이가 얼마나 깊은가
  A → B → C → D, 테이블을 찾으면 깊게 댑스를 들어간다.
  A → B(D참조) → C → D, 아래와 같이 밸런스를 지속적으로 맞춰야 한다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/85daa4aa-dc77-45d2-884a-01fa6652d450/Untitled.png)

**정규화를 하기로 했다면 읽기시 데이터를 어떻게 가져올 것인가?**

- 테이블 조인을 많이 활용하는데, 이건 **고민해볼 문제**이다.
  → 테이블 조인은 결합도를 높이고, deadlock 이슈를 불러오기도 한다.
  → 조회용 데이터를 별도의 디비에 적용할 수도 있다.
  → 조인을 사용하면 유연성에 제약이 따르고, 갇히게 된다.
  → 다만 조인이 가지는 장점이 있으니, 장단점을 잘 판단해야 한다.
- **테이블 조인은 서로 다른 테이블의 결합도를 엄청나게 높인다.**
- 조회시에는 **성능이 좋은 별도 데이터베이스나 캐싱등 다양한 최적화 기법을 이용**할 수 있다.
- 조인을 사용하게 되면, 이런 기법들을 사용하는데 제한이 있거나 더 많은 리소스가 들 수 있다.
- 읽기 쿼리 한번 더 발생되는 것은 그렇게 큰 부담이 아닐 수도 있다.

## 4. 조회 최적화를 위한 인덱스 이해하기

|  | 메모리 | 디스크 |
| --- | --- | --- |
| 속도 | 빠름 | 느림 |
| 영속성 | 전원이 공급되지 않으면 휘발 | 영속성이 있음 |
| 가격 | 비쌈 | 저렴함 |
- 데이터베이스의 데이터는 결국 디스크에 저장된다.
- 디스크는 메모리에 비해 훨씬 느리다.
- 데이터베이스 성능의 핵심은 접근을 최소화 하는 것이다.

**디스크 접근을 줄이는 방식**

1. **메모리에 올라온 데이터로 최대한 요청을 처리하는 것**
   → 메모리 캐시 히트율을 높이는 것. 심지어 쓰기도 곧 바로 디스크에 쓰지 않고 메모리에 쓴다.
2. **메모리에 데이터 유실을 고려해 WAL(Write Ahead Log)를 사용**
   → 랜덤 I/O, 순차 I/O
    1. 랜덤 I/O - 랜덤하게 데이터를 가져온다.
    2. 순차 I/O - 연속된 블록의 데이터를 가져온다.
3. **대부분의 트랜잭션은 무작위하게 Write(랜덤 I/O)가 발생**
   이를 지연시켜 랜덤 I/O 횟수를 줄이는 대신 순차적 I/O를 발생시켜 정합성 유지

<aside>
💡 **WAL이란?**

"WAL"은 "Write-Ahead Logging"의 약어로, 데이터베이스에서의 트랜잭션 로깅 방식 중 하나이다. WAL은 데이터베이스의 성능과 내구성을 향상시키기 위해 사용되는 기술이다.

WAL 방식은 데이터베이스 트랜잭션이 커밋되기 전에 해당 트랜잭션의 로그를 먼저 디스크에 기록하는 방식이다. 이렇게 로그를 먼저 기록함으로써, 트랜잭션의 변경 내용이 실제 데이터 파일에 반영되기 전에 로그를 통해 변경 내용을 복구할 수 있게 된다. 이는 데이터베이스의 내구성을 보장하고, 데이터 손실을 방지하는 데 도움을 준다.

또한 WAL은 데이터베이스의 성능을 향상시키는데 도움을 준다. 트랜잭션의 변경 내용을 로그에만 기록하므로 실제 데이터 파일에 대한 I/O 작업을 최소화할 수 있다. 이는 디스크 I/O의 부하를 줄이고, 데이터베이스의 처리량을 향상시키는 데 도움을 준다.

WAL은 많은 데이터베이스 시스템에서 사용되는 중요한 트랜잭션 로깅 방식 중 하나로, 데이터베이스의 성능과 내구성을 향상시키는 데 기여한다.

</aside>

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/39803f06-6105-412f-8fc8-101cec65788d/Untitled.png)

**⭐️ 결국 데이터 베이스 성능의 핵심은 디스크의 랜덤I/O(접근)을 최소화 하는 것이다.**

### 인덱스 이해하기

- 인덱스는 정렬된 자료구조, 이를 통해 탐색범위를 최소화
- 인덱스는 정렬되어 있어서, 타겟 데이터를 찾으면 그 뒤는 찾지 않아도 됨을 보장함
- 인덱스의 핵심은 탐색(검색) 범위를 최소화 하는 것

검색이 빠른 자료구조들은 어떤 것이 있을까?

**Hash Map, List, Binary Search Tree** 등이 있다.

1. **Hash Map**
    - 단건 검색 속도 O(1)
    - 그러나 범위 탐색은 O(N)
    - 전방 일치 탐색 불가 ex) like ‘AB%’
2. **List**
    - 정렬되지 않은 리스트의 탐색은 O(N)
    - 정렬된 리스트의 탐색은 O(logN)
    - 정렬되지 않은 리스트의 정렬 시간 복잡도는 O(N) ~ O(N * logN)
    - 삽입 / 삭제 비용이 매우 높음
3. **Tree(binary search)**
    - 트리 높이에 따라 시간 복잡도가 결정됨
    - **트리의 높이를 최소화하는 것이 중요!**
    - 한쪽으로 노드가 치우치지 않도록 균형을 잡아주는 트리 사용
      ex) Red-Black Tree, B+Tree
    - B+Tree
        - 삽입 / 삭제시 항상 균형을 이룸
        - 하나의 노드가 여러 개의 자식 노드를 가질 수 있음
        - 리프노드에만 데이터 존재
            - 연속적인 데이터 접근 시 유리
        - Oracle은 주소를 가지고 있고, MySQL은 PK 인덱스를 가지고 있음
        - PK를 물고 있고, 삽입/삭제가 발생할 때 DB에서도 동일하게 발생하기에 조회 성능은 올라가나 쓰기 성능은 저하됨

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/da470df7-2c4c-4f12-9c3f-9d7ca774e976/Untitled.png)

### 클러스터 인덱스

1. **클러스터 인덱스는 데이터 위치를 결정하는 키값이다.**
    1. 정렬된 자료구조이고 클러스터 키 위치에 따라 데이터 주소가 결정된다.
       → 클러스터 키 삽입/갱신시 성능 이슈가 발생할 수 있다
2. **MySQL의 PK는 클러스터 인덱스다.**
3. **MySQL에서 PK를 제외한 모든 인덱스는 PK를 가지고 있다.**
    1. PK의 사이즈가 인덱스의 사이즈를 결정
    2. 세컨더리 인덱스만으로는 데이터를 찾아갈 수 없다.
       → PK 인덱스를 항상 검색해야 함

<aside>
💡 **PK - Auto Increment VS UUID**

MySQL에서 기본 키 (Primary Key, PK)로 Auto Increment와 UUID(Universally Unique Identifier) 중 어떤 것이 더 좋은지는 상황에 따라 다를 수 있다. 각각의 장단점을 고려하여 사용해야 한다.

**Auto Increment**

- **장점**
    - 자동으로 순차적으로 증가하는 값으로 기본 키를 생성하므로, 간단하고 사용하기 쉽다.
    - 정수로 구성되어 있어 저장 공간이 작고 인덱스의 성능이 높아질 수 있다.
    - 삽입 작업이 빈번하게 일어나는 경우에는 Auto Increment가 성능상 유리할 수 있다.
- **단점**
    - 분산 환경에서 데이터를 병합하거나 동기화하는 경우에 충돌이 발생할 수 있다.
    - 데이터베이스가 복제되거나 이관되는 경우에도 중복된 값이 발생할 수 있다.
    - 기본적으로 숫자로만 구성되어 있어 가독성이 낮을 수 있다.

**UUID**

- **장점**
    - UUID는 전 세계적으로 고유한 값을 생성하므로, 분산 환경에서 충돌 없이 기본 키를 생성할 수 있다.
    - 문자열로 구성되어 있어 가독성이 높고, 다양한 데이터 형식에 사용될 수 있다.
    - 복제나 이관과 같은 작업에도 중복된 값이 발생하지 않다.
- **단점**
    - 저장 공간이 더 크므로, 인덱스의 성능이 Auto Increment보다 낮을 수 있다.
    - 자동 증가하는 값이 아니기 때문에, 삽입 작업이 빈번하게 일어나는 경우 성능이 저하될 수 있다.

결론적으로, Auto Increment와 UUID 중 어떤 것이 더 좋은지는 **사용하는 데이터베이스 시스템의 요구 사항과 환경, 데이터 모델 등에 따라 다르며, 고려해야 할 다양한 요소**가 있다. **성능, 고유성, 가독성, 저장 공간 등을 고려하여 적절한 기본 키 전략을 선택**해야 한다.

</aside>

**클러스터 인덱스 장점**

1. PK를 활용한 검색이 빠르다.
    1. 특히 범위 검색
    2. 공간적 캐시 이점
2. 세컨더리 인덱스들이 PK를 가지고 있어 커버링에 유리

### ⭐️ 인덱스를 다룰 때 주의해야 할 점

1. **인덱스 필드 가공**
2. **복합 인덱스**
3. **하나의 쿼리에는 하나의 인덱스만**

```jsx
// age는 int 타입
SELECT *
FROM Member
WHERE age * 10 = 1; // or age = '1';
```

age * 10 연산이기 때문에 인덱스를 타지 않는다.
혹은 타입을 잘못 입력하면 인덱스를 타지 않는다.

**복합 인덱스**

- 첫 인덱스 이후 두번째 인덱스 순서로 정렬되고 이후 세번째 인덱스 순서로 정렬된다.
- 즉 첫 인덱스는 정렬되어 있기 때문에 선두 인덱스를 어떤 것으로 정할지가 중요하다.

하나의 쿼리에는 하나의 인덱스만 탄다.
즉, 여러 인덱스 테이블을 동시에 탐색하지 않는다.
index merge hint를 사용하면 가능하긴 하다.
where order by, group by 혼합해서 사용할 때에는 인덱스를 잘 고려해야 한다.

- 의도대로 인덱스가 동작하지 않을 수 있어서 **explain으로 확인**한다.
- 인덱스도 비용이다.
  → **쓰기를 희생하고 조회를 얻는 것**이다.
- **꼭 인덱스로만 해결할 수 있는 문제인지 고민해야 한다.**
- ⭐️ **카디널리티가 높은 값, 즉 식별값이 높은 값으로 설정하는 게 좋다.**

## 5. 페이징 처리

### 오프셋 기반 페이징 구현의 문제

마지막 페이지를 구하기 위해 전체 갯수를 알아야 함
→ 데이터 사이즈가 커질수록 전체 데이터 개수를 구하는 게 부하가 될 수 있음
→ 대안은 정보 접근을 막거나, 무한 스크롤 형태로

offset 4 → limit 3
4번 오프셋을 시작하기 위해 0~3번 오프셋까지 데이터를 다시 읽음, 즉 버려지는 데이터들이 있음

**커서기반 페이징**

- 페이지가 아닌 키 번호를 줌 → key 4 size 2 응답으로 key 6
- 커서 기반 페이징은 키를 기준으로 데이터 탐색 범위 최소화
- 커서기반 페이징은 전체 데이터를 조회하지 않기 때문에 UI 구현이 어려움
- 카운트 쿼리가 나가지 않는 이점이 있음

중복데이터에 대한 여부를 고려해야 한다.
오프셋은 1페이지를 보고 있다가 2페이지로 넘어갔을 때 데이터가 더 많아지게 될 때 데이터가 늘어나면 밀려서 또 보이게 되는데, 커서 기반 페이지는 키값을 가지고 조회하기 때문에 중복이 발생하지 않는다.

### 커버링 인덱스

검색 조건이 인덱스에 부합하다면, 테이블에 바로 접근하는 것보다 인덱스를 통해 접근하는 것이 매우 빠르다.

그렇다면 테이블에 접근하지 않고 인덱스로만 데이터 응답을 내려줄 순 없을까?

즉 MySQL에서는 PK가 클러스터 인덱스이기 때문에 커버링 인덱스에 유리하다.
커버링 인덱스라는 것은 테이블에 접근하지 않고 인덱스로만 데이터 응답을 충분히 내려줄 수 있으면 사용 가능하다. 테이블에 직접 접근하는 쿼리보다 훨씬 빠르다.

커버링 인덱스로 어떻게 최적화 할까?
→ 나이가 30 이하인 회원의 이름을 2개만 조회

```sql
with 커버링 as (
SELECT id
FROM 회원
WHERE 나이 < 30
LIMIT 2
)

SELECT 이름
FROM 회원 INNER JOIN 커버링 on 회원.id = 커버링.id;
```

**LIMIT, ORDER BY, OFFSET 등은 불필요한 데이터블록 접근을 커버링 인덱스를 통해 최소화로 랜덤 I/O를 줄인다.**

## 6. 타임라인

기존 진행한 방식은 **Fan Out On Read(Pull Model)**이라고 한다.
사용자가 매번 홈에 접속할 때마다 부하가 발생한다.

⭐️ **구현한 타임라인의 시간복잡도를 구할 수 있고, 여기서 발생하는 병목구간을 캐치할 수 있어야 한다.**

### 타임라인(Fan On Write)

**Fan Out On Write(Push Model)**
게시글 작성시, 해당 회원을 팔로우하는 회원들에게 데이터를 배달한다.

타임라인 조회시에는 타임라인 테이블을 조회하여 데이터를 가져온다.
Pull 모델의 조회 시점에 발생하는 부하를 쓰기시점의 부하로 치환한다.

**Push Model은 공간 복잡도를 희생
Pull Model은 시간 복잡도를 희생**

어떤 모델이 정합성을 보장하기 쉬울까?

- Pull 모델은 원본 데이터를 직접 참조하기 때문에 정합성 보장에 유리하다.
- Follow가 많을 수록 느리다는 단점이 있다.
  → 페이스북의 경우 친구를 5천명으로 제한해서, 친구를 끊기 전까지는 늘릴 수 없다.
  → 트위터의 경우 5천개로 제한하는 것은 비슷하나, 나를 팔로우 하는 사람이 늘어나면 5천개를 넘길 수 있다.

Push 모델에서는 **게시글 작성과 타임라인 배달의 정합성 보장에 대한 고민이 필요**하다.
모든 회원의 타임라인에 배달되기 전까지 게시글 작성의 트랜잭션을 유지하는 것이 맞을까?

**CAP 이론**
→ 일관성, 고가용성, 파티션 네트워크 이 3가지의 밸런스를 모두 충족할 수 없다. 3가지 중에 2가지만 가져갈  수 있다.

<aside>
💡 **CAP 이론이란?**

CAP 이론은 분산 컴퓨팅 시스템에서 데이터베이스의 세 가지 속성인 일관성(Consistency), 가용성(Availability), 분할 내성(Partition tolerance) 중에서 최대 두 가지만을 동시에 보장할 수 있다는 이론이다. CAP은 Consistency, Availability, Partition tolerance의 첫 글자를 딴 약어이기도 하다.

1. **일관성(Consistency)**
   → 모든 노드가 동일한 시점의 데이터를 볼 수 있어야 하며, 모든 복제본에 대한 업데이트는 원자적으로 처리되어야 한다.
2. **가용성(Availability)**
   → 모든 클라이언트 요청에 대해 응답이 있어야 합니다. 어떤 노드가 실패하더라도 다른 노드들은 정상적으로 작동하여 서비스를 제공해야 한다.
3. **분할 내성(Partition tolerance)**
   → 시스템 내에 네트워크 분할이 발생하더라도 시스템이 계속해서 작동해야 한다.

CAP 이론은 이러한 세 가지 속성 중에서 두 가지만을 선택할 수 있다는 것을 주장한다. 즉, 모든 노드의 데이터 일관성과 가용성, 그리고 네트워크 분할 발생 시에도 작동하는 분할 내성을 모두 동시에 만족하는 것은 불가능하다는 것을 의미한다. 따라서 분산 컴퓨팅 시스템에서는 CAP 이론에 따라 일관성, 가용성, 분할 내성 중에서 필요에 따라 두 가지를 선택하고 이를 적절하게 조절해야 한다. 이를 통해 시스템의 디자인과 운영을 결정하게 된다.

</aside>

Push 모델은 Pull 모델보다 시스템 복잡도가 높다.
하지만 그만큼 비즈니스, 기술 측면에서 유연성을 확보시켜준다.

⭐️ **결국 은총알은 없다. 상황, 자원, 정책 등 여러가지를 고려해 트레이드 오프 해야한다.**

## 7. 트랜잭션

**여러 SQL문을 하나의 오퍼레이션으로 묶을 줄 알아야 한다.**

### **트랜잭션 ACID(원자성, 일관성, 고립성, 지속성)**

MySQL에서의 트랜잭션은 ACID라는 속성을 따른다.
ACID는 데이터베이스 트랜잭션의 네 가지 기본 속성을 나타내는 약어이다.

1. **원자성(Atomicity)**
   → 트랜잭션의 모든 연산은 원자적으로 처리되어야 한다. 즉, 트랜잭션 내에서 수행된 모든 작업이 전부 성공하거나, 전부 실패하거나 둘 중 하나만이 일어나야 한다. 하나의 연산이라도 실패할 경우, 트랜잭션은 이전 상태로 롤백되어야 한다. 모든 연산이 성공한 경우에만 커밋(commit)이 수행되어 트랜잭션이 완료된다.
2. **일관성(Consistency)**
   → 트랜잭션이 시작되기 전과 끝난 후에도 데이터베이스는 일관된 상태를 유지해야 한다. 즉, 트랜잭션이 수행되는 동안 데이터베이스의 일관성이 깨지면 안된다. 트랜잭션이 성공적으로 완료되면 데이터베이스는 일관된 상태로 변환되어야 한다.
    - **유니크 제약(Unique Constraint)**
      → 유니크 제약은 특정 컬럼이나 컬럼들의 조합에 대해 중복된 값을 허용하지 않는 제약 조건이다. 즉, 유니크 제약이 설정된 컬럼에는 중복된 값을 저장할 수 없다. 이를 통해 데이터베이스의 일관성을 유지할 수 있다. 예를 들어, 사용자 테이블에서 사용자의 이메일 주소가 유니크 제약으로 설정되어 있다면, 동일한 이메일 주소를 가진 사용자를 중복해서 저장하는 것을 방지할 수 있다.
    - **외래키 제약(Foreign Key Constraint)**
      → 외래키 제약은 다른 테이블의 기본키를 참조하는 컬럼에 대한 제약 조건이다. 외래키 제약을 가진 테이블의 컬럼에는 참조된 테이블의 기본키 값만 저장할 수 있다. 이를 통해 데이터베이스 간의 관계를 유지하고 데이터의 일관성을 유지할 수 있다. 예를 들어, 주문 테이블에서 주문 상품의 상품 번호가 외래키 제약으로 설정되어 있다면, 존재하지 않는 상품 번호를 참조하는 주문을 방지할 수 있다.
3. **격리성(Isolation)**
   → 여러 개의 트랜잭션이 동시에 실행될 때 각각의 트랜잭션은 다른 트랜잭션에게 영향을 미치지 않고 독립적으로 실행되는 것처럼 보여야 한다. 즉, 트랜잭션은 다른 트랜잭션의 결과를 참조하지 않고, 다른 트랜잭션에 의해 변경된 데이터를 보지 않아야 한다. 이를 통해 트랜잭션 간의 간섭이 없도록 보장된다.
   **트랜잭션 격리레벨을 통해 가능하다.**

    <aside>
    💡 **MVCC 패턴이란?**

   MVCC 패턴은 Multi-Version Concurrency Control 패턴의 약자로, 데이터베이스 관리 시스템(DBMS)에서 병행성(Concurrency)을 제어하기 위한 방법 중 하나이다. MVCC 패턴은 여러 개의 버전(Version)을 사용하여 동시에 여러 트랜잭션(Transaction)이 데이터를 읽고 쓰는 것을 허용하며, 동시성 제어를 통해 데이터 일관성(Consistency)을 유지하는 방식이다.

   일반적으로, 데이터베이스에서 병행성을 제어하기 위해 락(Lock)을 사용하는 방법이 있다. 그러나 락을 사용하면 동시성이 저하되고 성능이 저하될 수 있다. MVCC 패턴은 락을 사용하지 않고, 각 트랜잭션이 별도의 버전을 사용하여 데이터를 읽고 쓸 수 있도록 함으로써 병행성을 향상시키는 방법이다.

   MVCC 패턴에서는 각 트랜잭션이 독립적인 버전(Version)을 가지고 있다. 각 버전은 트랜잭션의 시작 시간과 종료 시간을 기록하고, 데이터를 읽거나 쓸 때 해당 버전의 데이터를 사용한다. 이를 통해 여러 트랜잭션이 동시에 데이터를 읽고 쓸 수 있고, 서로의 작업에 영향을 주지 않으면서 데이터 일관성을 유지할 수 있다.

   MVCC 패턴은 데이터베이스 시스템에서 다중 사용자 환경에서 동시성을 제어하기 위해 사용되며, 일반적으로 분산 데이터베이스 시스템이나 멀티코어 시스템에서 효과적으로 사용된다. 예를 들면, PostgreSQL, MySQL의 InnoDB 스토리지 엔진, Oracle의 Oracle Database 등에서 MVCC 패턴이 적용되어 있다.

    </aside>

4. **지속성(Durability)**
   → 트랜잭션이 성공적으로 완료된 경우, 해당 트랜잭션에 의해 변경된 데이터는 영구적으로 저장되어야 한다. 시스템에 장애가 발생하더라도 트랜잭션이 커밋된 데이터는 계속해서 보존되어야 한다.
   **WAL을 통해 해소가 가능하다.**

ACID 속성은 데이터베이스에서 트랜잭션의 안전성과 일관성을 보장하여 데이터의 무결성과 일관성을 유지하고, 다중 사용자가 동시에 데이터베이스에 접근하는 환경에서의 데이터 일관성을 보장한다. 이를 통해 MySQL에서의 트랜잭션은 안전하게 데이터를 처리할 수 있도록 도와준다.

**트랜잭션 전파란?**

트랜잭션 전파(Transaction Propagation)은 분산 트랜잭션(Distributed Transaction)에서 여러 개의 데이터베이스 또는 리소스(예: 데이터베이스 서버)를 포함하는 트랜잭션의 범위를 결정하는 과정을 말한다. 분산 트랜잭션은 여러 개의 데이터베이스나 리소스를 거칠 때 데이터 일관성과 동시성을 유지하기 위해 트랜잭션 전파 규칙이 필요하다.

트랜잭션 전파는 일반적으로 다음과 같은 목적으로 사용된다.

1. **트랜잭션의 범위 제어**
   → 분산 환경에서 여러 개의 데이터베이스나 리소스가 연관되어 작업이 수행되는 경우, 트랜잭션 전파를 통해 트랜잭션의 범위를 제어할 수 있다. 예를 들어, 특정 트랜잭션에서 여러 개의 데이터베이스에 대한 작업을 수행하는 경우, 모든 작업을 하나의 트랜잭션으로 묶을 수 있다.
2. **트랜잭션의 일관성 유지**
   → 분산 환경에서 여러 개의 데이터베이스나 리소스를 거치는 트랜잭션에서 일관성을 유지하기 위해 트랜잭션 전파 규칙이 필요하다. 예를 들어, 한 트랜잭션에서 데이터베이스 A와 B를 거치는 경우, 트랜잭션 전파를 통해 두 데이터베이스 간의 일관성을 유지할 수 있다.
3. **트랜잭션의 동시성 제어**
   → 분산 환경에서 여러 개의 트랜잭션이 동시에 수행될 때 트랜잭션 전파 규칙을 통해 동시성을 제어할 수 있다. 예를 들어, 한 트랜잭션에서 데이터베이스 A와 B를 거치는 경우, 다른 트랜잭션이 동시에 같은 데이터베이스에 접근하여 충돌이 발생하는 것을 방지할 수 있다.

트랜잭션 전파 규칙은 각 데이터베이스 또는 리소스의 트랜잭션 관리 기능에 따라 다를 수 있다. 일반적으로 트랜잭션 전파는 명시적인 설정이 필요하며, 애플리케이션 레벨이나 데이터베이스 레벨에서 구성할 수 있다.

### 트랜잭션 격리 레벨

트랜잭션 격리 레벨(Isolation Level)은 데이터베이스에서 동시에 여러 개의 트랜잭션이 수행될 때, 각 트랜잭션이 서로에게 어떻게 보이는지를 제어하는 설정이다. 일반적으로 데이터베이스 시스템은 다양한 격리 레벨을 제공하며, 높은 격리 레벨은 트랜잭션 간의 동시성을 낮추고 데이터 일관성을 유지하는 대신에, 낮은 격리 레벨은 트랜잭션 간의 동시성을 높이고 데이터 일관성을 희생할 수 있다.

ISOLATION - **트랜잭션은 서로 간섭하지 않고 독립적으로 동작**한다

- **READ UNCOMMITTED**
- **READ COMMITTED**
- **REPEATABLE READ**
- **SERIALIZABLE READ**

이 4가지보다 중요한 것은 이 4가지는 아래 3가지 형상으로 구분된다.

- **Dirty Read(더티 리드)
  →** 한 트랜잭션이 아직 커밋되지 않은 다른 트랜잭션의 변경된 데이터를 읽는 현상이다. Dirty Read가 발생하면 트랜잭션이 아직 완료되지 않은 다른 트랜잭션의 변경사항을 볼 수 있어, 데이터의 무결성과 일관성이 깨질 수 있다.
- **Non Repeatable Read(반복되지 않는 리드)
  →** 한 트랜잭션이 같은 쿼리를 두 번 이상 수행할 때, 그 사이에 다른 트랜잭션이 데이터를 변경하는 현상이다. Non-repeatable Read가 발생하면 트랜잭션 내에서 같은 쿼리를 두 번 이상 실행해도 결과가 달라지는 것을 의미하며, 데이터의 무결성과 일관성이 깨질 수 있다.
- **Phantom READ(유령 리드)
  →**한 트랜잭션이 같은 범위의 쿼리를 두 번 이상 수행할 때, 그 사이에 다른 트랜잭션이 데이터를 추가 또는 삭제하는 현상이다. Phantom Read가 발생하면 트랜잭션 내에서 같은 범위의 쿼리를 두 번 이상 실행해도 결과가 달라지는 것을 의미하며, 데이터의 무결성과 일관성이 깨질 수 있다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/59d20baf-65ce-4501-a39f-3245b02196fe/Untitled.png)

**아래로 갈수록 이상현상이 없음, 허나 동시처리량이 처참하다.**
READ COMMITTED, REPEATABLE READ를 주로 사용한다.

이러한 확장된 이상 현상들은 트랜잭션 격리 레벨이 낮을 때 발생할 수 있다. 따라서 **트랜잭션 격리 레벨을 선택할 때는 데이터베이스 시스템과 응용 프로그램의 요구에 따라 충분한 격리 수준을 선택하는 것이 중요하다.** 일반적으로 트랜잭션 격리 레벨이 높을수록 확장된 이상 현상이 발생할 가능성이 낮아지지만, 동시성이 낮아질 수 있다. 반대로 트랜잭션 격리 레벨이 낮을수록 동시성이 높아지지만, 확장된 이상 현상이 발생할 가능성이 높아진다.

가장 강력한 격리 레벨인 `Serializable(직렬화)`을 사용하면 확장된 이상 현상이 발생하지 않지만, 동시성이 매우 낮아질 수 있다. 반면에 가장 낮은 격리 레벨인 `Read Uncommitted(읽기 미커밋)`을 사용하면 동시성이 높아지지만, 확장된 이상 현상이 발생할 가능성이 높아진다.

중간에 위치하는 격리 레벨인 `Read Committed(읽기 커밋)`, `Repeatable Read(반복 가능한 리드)`, `Snapshot Isolation(스냅샷 격리)` 등은 다양한 트랜잭션 격리 수준을 제공하며, 데이터베이스 시스템에 따라 다를 수 있다.

⭐️ **따라서 트랜잭션 격리 레벨을 선택할 때는 응용 프로그램의 요구사항과 동시성, 데이터 일관성 등을 고려하여 적절한 격리 레벨을 선택하는 것이 중요하다.**

## 8. 멀티 스레드 환경에 대한 이해

대부분 하나의 웹 서버는 여러 개의 요청을 동시에 수행할 수 있다.
반대로 작성한 코드 한 줄은 동시에 수행될 수 있다
→ 하나의 자원을 두고 여러 개의 연산들이 경합하면, 데이터 정합성을 깨뜨릴 수 있다.

동시성 이슈가 발생하는 일반적인 패턴

1. **공유자원 조회**

**→ 다른 오퍼레이션 수행이 되면**

1. **공유자원 갱신**

**대안은 공유 자원에 대한 잠금을 획득하여 줄 세우기!**

**동시성 이슈가 어려운 이유**

1. 로컬에서는 대부분 하나의 스레드로 테스트
2. 이슈가 발생하더라도 오류가 발생하지 않음
3. 코드에서 잘 보이지 않음
4. 항상 발생하지 않고 비결정적으로 발생

⭐️ **작성한 코드 한 줄은 동시에 수행될 수 있다. 유의해서 개발해야 함**

### 쓰기락과 읽기락

동시성 제어를 위한 가장 보편적인 방법은 락을 통한 줄세우기

락을 통해 동시성을 제어할 때는, 락의 범위를 최소화 하는 것이 중요

**MySQL에서는 트랜잭션의 커밋 혹은 롤백시점에 잠금이 풀림
→ 트랜잭션이 곧 락의 범위**

**외부 I/O가 발생하는 것들은 최대한 트랜잭션 범위 밖에서 해주는 것이 좋다.**

MySQL에서는 쓰기락(Exclusive Lock), 읽기락(Shared Lock)을 제공한다.

|  | 읽기락(Shared Lock) | 쓰기락(Exclusive Lock) |
| --- | --- | --- |
| 읽기락(Shared Lock) | O | 대기 |
| 쓰기락(Exclusive Lock) | 대기 | 대기 |

읽기락 - SELECT … FOR SHARE
쓰기락 - SELECT … FOR UPDATE or UPDATE, DELETE 쿼리

매번 잠금이 발생할경우, 성능 저하를 피할 수 없음
→ MySQL에서 일반 SELECT는 `nonblocking consistent read`로 동작, Undo Redo

참고문서
→ https://dev.mysql.com/doc/refman/5.7/en/innodb-consistent-read.html

**MySQL에서 잠금은 row가 아니라 레코드 락인 인덱스를 잠근다
→ 인덱스가 없는 조건으로 Locking Read시 불필요한 데이터들이 잠길 수 있음
→ 즉 테이블 전체 데이터의 락이 걸려버린다. 락을 획득할 때는 인덱스를 꼭 확인하자**

- **Java에서의 동시성 이슈 제어방법**
    1. **동기화(Synchronization)**
       → Java에서는 **`synchronized`** 키워드를 사용하여 여러 스레드가 공유하는 리소스에 대한 접근을 제어할 수 있다. **`synchronized`** 키워드를 사용하면 특정 블록 또는 메소드에 대한 잠금(lock)을 설정하여 한 스레드가 해당 블록 또는 메소드를 실행하는 동안 다른 스레드들은 대기하게 된다. 이를 통해 여러 스레드 사이에서의 동시 접근을 제어하여 동시성 이슈를 방지할 수 있다.
    2. **병렬 컬렉션(Concurrent Collections)**
       → Java에서는 **`java.util.concurrent`** 패키지에 여러 가지 병렬 컬렉션 클래스들이 제공된다. 예를 들어, **`ConcurrentHashMap`**, **`ConcurrentLinkedQueue`**, **`ConcurrentSkipListSet`** 등이 있다. 이들 컬렉션 클래스들은 여러 스레드가 동시에 접근하여 수정할 수 있는 동시성 이슈를 고려하여 구현되어 있어, 명시적인 동기화 없이도 스레드 간의 안전한 접근이 가능하다.
    3. **원자적 연산(Atomic Operations)**
       → Java에서는 **`java.util.concurrent.atomic`** 패키지에 여러 가지 원자적 연산 클래스들이 제공된다. 예를 들어, **`AtomicInteger`**, **`AtomicLong`**, **`AtomicReference`** 등이 있다. 이들 클래스들은 원자적인(read-modify-write) 연산을 수행하여 여러 스레드가 동시에 접근하여 수정하는 경우에도 동시성 이슈를 방지할 수 있다.
    4. **Lock과 Condition**
       → Java에서는 **`java.util.concurrent.locks`** 패키지에 다양한 락(Lock) 클래스들이 제공된다. 예를 들어, **`ReentrantLock`**, **`ReadWriteLock`**, **`StampedLock`** 등이 있다. 이들 락 클래스들을 사용하여 명시적인 락을 설정하고 해제하여 스레드 간의 동기화를 제어할 수 있다. 또한, **`Condition`** 인터페이스를 사용하여 스레드 간의 통신을 가능하게 할 수 있다.
    5. 이 외에도 **스레드 풀(Thread Pool)**과 같은 방식이 있다.
- **분산환경에서의 동시성 이슈 제어방법**
    1. **락(Lock) 및 동기화 기술 사용**
       → 락과 동기화 기술을 사용하여 공유 자원에 대한 동시 접근을 제어할 수 있다. 예를 들어, Java에서는 **`synchronized`** 키워드를 사용하여 동기화를 구현할 수 있다. 락을 사용하면 특정 시점에는 하나의 스레드만이 공유 자원에 접근할 수 있도록 보장된다.
    2. **메시지 큐(Message Queue) 및 이벤트 기반 아키텍처 사용**
       → 메시지 큐를 통해 작업을 큐에 넣고, 여러 스레드 또는 서버 간에 메시지를 주고받아 동시성을 제어할 수 있다. 이벤트 기반 아키텍처에서는 이벤트를 통해 비동기적으로 작업을 처리하므로, 동시성 이슈를 줄일 수 있다.
    3. **무상태(Stateless) 아키텍처 사용**
       → 무상태 아키텍처에서는 각 요청이 서로 독립적이며 상태를 공유하지 않는 구조를 가진다. 이를 통해 여러 스레드 또는 서버 간에 상태를 공유할 필요가 없어 동시성 이슈를 제어할 수 있다.
    4. **무결성(Integrity) 제약 및 트랜잭션(Transaction) 사용**
       → 무결성 제약을 통해 여러 작업이 동시에 실행될 때 데이터의 일관성을 유지할 수 있다. 또한, 트랜잭션을 사용하여 여러 작업을 묶어 원자적으로 실행되도록 처리하여 동시성 이슈를 제어할 수 있다.
    5. **캐싱(Caching) 및 레디스(Redis)와 같은 인메모리 데이터베이스 사용**
       → 캐싱을 통해 공유 데이터를 빠르게 조회하고, 인메모리 데이터베이스를 사용하여 높은 처리량과 낮은 지연시간을 가진 데이터 액세스를 구현함으로써 동시성 이슈를 제어할 수 있다.
    6. **분산 락(Distributed Locking) 사용**
       → 여러 서버 간에 동시 접근을 제어하기 위해 분산 락을 사용할 수 있다. 예를 들어, ZooKeeper와 같은 분산 코디네이션 서비스를 사용하여 분산 락을 구현할 수 있다. 이를 통해 여러 서버 간에 공유 자원에 대한 접근을 동기화하고 동시성 이슈를 제어할 수 있다.
    7. **액터(Actor) 모델 사용**
       → 액터 모델은 분산 환경에서 동시성을 제어하는 또 다른 방법이다. 액터는 독립적으로 동작하는 개체로, 메시지를 주고받으며 상태를 변경할 수 있다. 액터 모델을 사용하면 각 액터가 독립적으로 실행되므로, 여러 액터 간에 동시성 이슈를 최소화할 수 있다.
    8. **적절한 샤딩(Sharding) 및 파티셔닝(Partitioning) 사용**
       → 데이터베이스나 분산 시스템에서 적절한 샤딩이나 파티셔닝을 사용하여 동시에 다수의 작업이 수행될 때 데이터의 충돌이나 경합을 줄일 수 있다. 각 샤드 또는 파티션이 독립적으로 동작하므로, 동시성 이슈를 최소화할 수 있다.
    9. **CAP 이론에 따른 무결성, 가용성, 분할 허용성 관리**
       → CAP 이론은 분산 시스템에서 무결성, 가용성, 분할 허용성 중 2개를 선택해야 한다는 원칙이다. 동시성 이슈를 제어하기 위해서는 이러한 원칙에 따라 데이터베이스나 분산 시스템의 설정을 관리하여 적절한 균형을 유지할 수 있다.
- **MySQL의 넥스트 키락이 등장한 배경**

  MySQL의 넥스트 키 락(Next-Key Lock)은 트랜잭션 격리 수준 중 하나인 Repeatable Read에서 사용되는 락이다. 넥스트 키 락은 특정 행의 락 뿐만 아니라 그 다음 키의 락까지 함께 설정하는 락으로, 트랜잭션 내에서 다음에 삽입될 레코드에 대한 락을 설정하여 격리 수준을 유지한다.

  넥스트 키 락의 배경에는 MySQL의 다중 버전 동시성 제어(MVCC) 기능이 있다. MVCC는 MySQL에서 동시성을 제어하기 위해 사용되는 기술로, 각 행에 대해 별도의 버전을 유지하여 여러 트랜잭션이 동시에 접근해도 각 트랜잭션이 자신만의 버전을 참조하도록 한다. 이를 통해 락의 충돌을 최소화하고 동시성을 향상시킬 수 있다.

  하지만 MVCC를 사용할 때에는 트랜잭션 격리 수준에 따른 문제가 발생할 수 있다. 예를 들어, Repeatable Read 격리 수준에서는 한 트랜잭션이 특정 범위에 락을 설정하면 그 범위에 해당하는 레코드에 대한 락이 설정되는데, 이 때 넥스트 키 락이 사용된다. 넥스트 키 락을 사용하여 다음에 삽입될 레코드에 대한 락을 설정함으로써, 현재 트랜잭션이 해당 범위의 레코드에 대한 동시적인 삽입을 막고, 격리 수준을 유지할 수 있다.

  **따라서 넥스트 키 락은 MVCC를 기반으로한 MySQL의 트랜잭션 격리 수준을 유지하기 위해 도입된 기능으로 볼 수 있다.**

- **MySQL 외래키로 인한 잠금**

  MySQL에서 외래키(Foreign Key)로 인한 잠금은 부모 테이블과 자식 테이블 간의 관계를 유지하기 위해 사용되는 기능으로, 외래키를 사용하는 테이블의 레코드를 수정하거나 삭제할 때 발생하는 잠금을 말한다.

  외래키를 설정한 테이블에서 레코드를 수정하거나 삭제할 때, 해당 레코드와 관련된 다른 테이블에서 외래키를 참조하고 있는 경우, MySQL은 외래키 제약 조건을 체크하고, 일관성을 유지하기 위해 잠금을 설정한다. 이로 인해 다른 트랜잭션이나 세션에서 동일한 레코드에 대한 수정이나 삭제를 시도할 경우, 잠금으로 인해 대기 상태에 들어가게 된다.

  MySQL에서는 외래키로 인한 잠금은 InnoDB 스토리지 엔진에서만 동작한다. InnoDB는 외래키를 지원하며, 외래키로 설정된 컬럼에 대한 레코드 수정이나 삭제 시, 관련된 레코드에 대한 잠금을 설정하여 일관성을 유지한다. 다른 스토리지 엔진인 MyISAM은 외래키를 지원하지 않으므로, 외래키로 인한 잠금이 발생하지 않는다.

  외래키를 사용할 때에는 잠금에 주의해야 하며, 효율적인 데이터베이스 설계와 적절한 인덱싱을 통해 잠금 충돌을 최소화하는 것이 중요하다. 또한, 외래키를 사용할 경우, 데이터의 무결성을 유지하고 일관성 있는 관계를 구성할 수 있어, 데이터베이스의 정합성을 보장하는데 도움이 된다.

- **MySQL 데드락**

  MySQL에서 데드락(Deadlock)은 두 개 이상의 트랜잭션이 각각 자원을 점유하고 다른 트랜잭션이 점유한 자원을 기다리며 무한히 대기하는 상태이다. 이렇게 두 개 이상의 트랜잭션이 서로 자원을 점유하고 기다리며, 서로의 자원을 놓아주지 않아 무한한 대기가 발생하면, 시스템이 더 이상 진행할 수 없는 상태로 빠지게 되는데, 이를 데드락이라고 한다.

  데드락은 보통 다수의 트랜잭션이 병행 실행되는 환경에서 발생할 수 있다. 예를 들어, 트랜잭션 A가 자원 X를 점유한 상태에서 자원 Y를 요청하고, 동시에 트랜잭션 B가 자원 Y를 점유한 상태에서 자원 X를 요청하는 경우 데드락이 발생할 수 있다. 이 경우, 트랜잭션 A는 트랜잭션 B가 자원 Y를 놓아줄 때까지 무한히 대기하고, 트랜잭션 B도 트랜잭션 A가 자원 X를 놓아줄 때까지 무한히 대기하게 되어 데드락이 발생한다.

  MySQL은 데드락을 방지하기 위해 다양한 메커니즘을 제공하고 있다. 예를 들어, InnoDB 스토리지 엔진에서는 트랜잭션들 사이에서 자동으로 데드락을 검출하고 해결하는 기능을 제공하고 있다. 또한, MySQL에서는 데드락이 발생할 경우, 일부 트랜잭션을 롤백하여 데드락을 해제하는 기능을 가지고 있다.

  **데드락은 데이터베이스 시스템에서 주의해야 할 중요한 이슈 중 하나이며, 효율적인 트랜잭션 관리와 데이터베이스 설계를 통해 데드락을 예방하고 처리하는 것이 중요하다.**


**컬럼에 디폴트값을 넣어주는 것은 테이블 락을 야기시키기도 한다.**

1. **테이블 잠금(Level Locking)**
   → MySQL에서는 테이블에 대한 레코드 레벨의 잠금이 아닌 테이블 레벨의 잠금도 존재한다. 테이블에 DEFAULT 값이 설정되어 있다면, 테이블에 새로운 레코드를 추가할 때 해당 DEFAULT 값으로 레코드가 삽입된다. 이 때, 테이블 레벨의 잠금이 발생하여 다른 트랜잭션들이 해당 테이블에 대한 작업을 기다려야 할 수 있습니다. 이는 동시성을 저하시킬 수 있다.
2. **테이블 구조 변경과 잠금**
   → 테이블의 DEFAULT 값은 테이블의 구조를 변경하는 작업에도 영향을 미칠 수 있다. 예를 들어, 테이블에 새로운 컬럼을 추가하고, 그 컬럼에 DEFAULT 값을 설정하는 경우, 해당 테이블의 모든 레코드에 대해 DEFAULT 값이 업데이트되어야 한다. 이 경우, 테이블 레벨의 잠금이 발생하여 다른 트랜잭션들이 해당 테이블에 대한 작업을 기다려야 할 수 있다.
3. **트리거와 잠금**
   → MySQL에서는 트리거(Trigger)라는 기능을 사용하여 특정 이벤트가 발생하면 자동으로 특정 동작을 수행할 수 있다. 트리거에 DEFAULT 값을 설정하는 경우, 해당 트리거가 동작할 때 테이블 레벨의 잠금이 발생하여 다른 트랜잭션들이 해당 테이블에 대한 작업을 기다려야 할 수 있다.

### 낙관적 락

**동시성 제어를 위한 가장 보편적인 방법은 락을 줄세우기 → 비관적 락**
락을 통한 동시성 제어는 불필요한 대기 상태를 만듦

동시성이 빈번하지 않은 쿼리로 인해 다른 쿼리가 대기한다면?
**동시성 이슈가 빈번하지 않길 기대하고, 어플리케이션에서 제어한다. → 낙관적 락**

CAS(compare and set)을 통해 제어

⭐️ **낙관적 락은 실패에 대한 처리를 직접 구현해야 함**

### 읽기와 쓰기의 트레이드 오프

1. **게시글에 컬럼 추가를 통한 구현 - 비관적 락**
2. **게시글에 테이블 추가를 통한 구현 - 낙관적 락**
3. 좋아요 테이블 추가를 통한 구현

- **컬럼을 통한 구현**
    1. 조회시 컬럼만 읽어오면 됨
    2. 쓰기시 게시글 레코드에 대한 경합이 발생
       → 하나의 자원을 두고 락 대기
    3. 같은 회원이 하나에 게시글에 대해 여러번 좋아요를 누를 수 있음
- **테이블을 통한 구현**
    1. 조회시 매번 count 쿼리 연산 → 큰 문제
    2. 쓰기시 경합없이 인서트만 발생
    3. 회원정보 등 다양한 정보 저장 가능

**병목 해소하기**
쓰기 지점의 병목은 하나의 레코드를 점유
조회 지점의 병목은 카운트 쿼리

좋아요 수는 높은 정합성을 요구하는 데이터인가?
좋아요는 어느정도의 실시간성만 보장되면 된다.

클라이언트 → 웹 서버 →(인서트) 좋아요 테이블 ← (특정 주기마다 count) 스케쥴러 →(좋아요 수 update) 게시글 테이블

- count 쿼리를 비약적으로 줄일 수 있지만 별도의 모듈을 관리해야 하며, 모듈의 에러가 발생하면 잘못된 데이터가 보여진다.
- 관리포인트가 늘어나고 시스템 복잡도가 올라간다는 단점이 있다.
- 게시글 테이블 스케쥴러가 곧바로 업데이트 하는데 redis를 쓰기 좋다(싱글쓰레드)

내가 누른 좋아요가 곧바로 반영이 될까? → 클라이언트 캐싱을 통해 어느정도 해소할 수 있다.

**데이터의 성질, 병목 지점 등을 파악하고, 적당한 기술들을 도입해 해소!**